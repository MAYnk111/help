#include <iostream>
#include <string>
using namespace std;

// Structure to store employee record
struct Employee {
    int id;
    string name;
    string department;
    Employee* left;
    Employee* right;
    int height;
};

// ---------- Utility Functions ----------
int getHeight(Employee* node) {
    return (node == NULL) ? 0 : node->height;
}

int getBalance(Employee* node) {
    if (node == NULL) return 0;
    return getHeight(node->left) - getHeight(node->right);
}

Employee* createNode(int id, string name, string department) {
    Employee* node = new Employee();
    node->id = id;
    node->name = name;
    node->department = department;
    node->left = node->right = NULL;
    node->height = 1;
    return node;
}

// ---------- Rotation Operations ----------
Employee* rightRotate(Employee* y) {
    Employee* x = y->left;
    Employee* T2 = x->right;

    // Perform rotation
    x->right = y;
    y->left = T2;

    // Update heights
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;

    return x;
}

Employee* leftRotate(Employee* x) {
    Employee* y = x->right;
    Employee* T2 = y->left;

    // Perform rotation
    y->left = x;
    x->right = T2;

    // Update heights
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;

    return y;
}

// ---------- Insert a new Employee ----------
Employee* insert(Employee* root, int id, string name, string dept) {
    if (root == NULL)
        return createNode(id, name, dept);

    if (id < root->id)
        root->left = insert(root->left, id, name, dept);
    else if (id > root->id)
        root->right = insert(root->right, id, name, dept);
    else {
        cout << "Duplicate Employee ID not allowed!\n";
        return root;
    }

    // Update height
    root->height = 1 + max(getHeight(root->left), getHeight(root->right));

    // Check balance and rotate if needed
    int balance = getBalance(root);

    // Left Left Case
    if (balance > 1 && id < root->left->id)
        return rightRotate(root);

    // Right Right Case
    if (balance < -1 && id > root->right->id)
        return leftRotate(root);

    // Left Right Case
    if (balance > 1 && id > root->left->id) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }

    // Right Left Case
    if (balance < -1 && id < root->right->id) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}

// ---------- Find Minimum Node ----------
Employee* findMin(Employee* node) {
    while (node->left != NULL)
        node = node->left;
    return node;
}

// ---------- Delete Employee ----------
Employee* deleteNode(Employee* root, int id) {
    if (root == NULL) return root;

    if (id < root->id)
        root->left = deleteNode(root->left, id);
    else if (id > root->id)
        root->right = deleteNode(root->right, id);
    else {
        // Node found
        if (root->left == NULL || root->right == NULL) {
            Employee* temp = root->left ? root->left : root->right;
            if (temp == NULL) {
                temp = root;
                root = NULL;
            } else
                *root = *temp;
            delete temp;
        } else {
            Employee* temp = findMin(root->right);
            root->id = temp->id;
            root->name = temp->name;
            root->department = temp->department;
            root->right = deleteNode(root->right, temp->id);
        }
    }

    if (root == NULL)
        return root;

    // Update height
    root->height = 1 + max(getHeight(root->left), getHeight(root->right));

    // Balance check
    int balance = getBalance(root);

    // Rotation cases
    if (balance > 1 && getBalance(root->left) >= 0)
        return rightRotate(root);

    if (balance > 1 && getBalance(root->left) < 0) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }

    if (balance < -1 && getBalance(root->right) <= 0)
        return leftRotate(root);

    if (balance < -1 && getBalance(root->right) > 0) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}

// ---------- Search Employee ----------
Employee* search(Employee* root, int id) {
    if (root == NULL || root->id == id)
        return root;
    if (id < root->id)
        return search(root->left, id);
    else
        return search(root->right, id);
}

// ---------- Display (Inorder Traversal) ----------
void inorder(Employee* root) {
    if (root != NULL) {
        inorder(root->left);
        cout << root->id << "\t" << root->name << "\t" << root->department << endl;
        inorder(root->right);
    }
}

// ---------- MAIN FUNCTION ----------
int main() {
    Employee* root = NULL;
    int choice, id;
    string name, dept;

    do {
        cout << "\n--- Employee AVL Tree Menu ---\n";
        cout << "1. Add Employee\n2. Delete Employee\n3. Search Employee\n4. Display All (Inorder)\n5. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter Employee ID, Name, Department: ";
                cin >> id >> name >> dept;
                root = insert(root, id, name, dept);
                break;

            case 2:
                cout << "Enter Employee ID to Delete: ";
                cin >> id;
                root = deleteNode(root, id);
                break;

            case 3:
                cout << "Enter Employee ID to Search: ";
                cin >> id;
                {
                    Employee* emp = search(root, id);
                    if (emp != NULL)
                        cout << "Found: " << emp->id << " " << emp->name << " (" << emp->department << ")\n";
                    else
                        cout << "Employee not found!\n";
                }
                break;

            case 4:
                cout << "\nEmployee Records (Inorder Traversal - Sorted by ID):\n";
                cout << "ID\tName\tDepartment\n";
                cout << "----------------------------------\n";
                inorder(root);
                break;

            case 5:
                cout << "Exiting...\n";
                break;

            default:
                cout << "Invalid choice!\n";
        }
    } while (choice != 5);

    return 0;
}
